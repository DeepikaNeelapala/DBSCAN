# -*- coding: utf-8 -*-
"""DBSCAN_Video.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iLfVPR5IZ-D5SfDZbzeBHYtonGo9OOoR
"""

# -*- coding: utf-8 -*-
"""
Created on Fri Jun  9 16:43:19 2023

@author: Lenovo
"""

import cv2
import time
import numpy as np
import os
from collections import deque
import pandas as pd
######################################################################################################################
np.set_printoptions(threshold=np.inf)
imageformat = ".png"

path = "/content/drive/MyDrive/dense data/video/43"
imfilelist = [os.path.join(path,f) for f in os.listdir(path) if f.endswith(imageformat)]


Images = []
for el in imfilelist:
    image = cv2.imread(el,0)
    #image = image[:400,:400]
    Images.append(image)
I = np.copy(Images)
print(np.shape(Images))

#image = cv2.imread("pca_comp1_anusha.png",0)
#orig = Images[0]

#####################################################################################################################
def preprocessing(Images):
    kernel = np.array([[-1, -1, -1], [-1, 3, -1], [-1, -1, -1]])
    Imgs = []
    for i in Images:
        clahe = cv2.createCLAHE(clipLimit=1000, tileGridSize=(10, 10))
        Hist1 = cv2.equalizeHist(i)

        Imgs.append(Hist1)
    Imgs = np.array(Imgs)

    x3 = []
    for i in range(Imgs.shape[1]):
        x2 = []
        for j in range(Imgs.shape[2]):
            x1 = []
            for k in Imgs:
                x1.append(k[i][j])
                # x1 = np.array(x1)
            x2.append(np.array(x1))
        x3.append(np.array(x2))

    ThreeD_Img = np.array(x3)

    # Normalize the ThreeD_Img
    ThreeD_Img_normalized = ThreeD_Img / 255.0

    return ThreeD_Img_normalized

threeD_Img = preprocessing(Images)

print(threeD_Img.shape)


#######################################################################################################################

def cos_sim(a,b):
    Dot = abs(np.dot(a,b))
    mod_a = np.linalg.norm(a)
    mod_b = np.linalg.norm(b)
    denominator = mod_a * mod_b
    cos_similarity = Dot/denominator
    return(cos_similarity)

#######################################################################################################################

def random_color():
	b = np.random.randint(255,size=(1,))
	g = np.random.randint(255,size=(1,))
	r = np.random.randint(255,size=(1,))

	Color = [b[0],g[0],r[0]]

	return np.array(Color)

#######################################################################################################################

Black = np.zeros((Images[0].shape[0], Images[0].shape[1],3))


def DBSCAN(D,rad,min_pts):
    #L = np.zeros(D.shape)
    d_values = np.zeros(D[:,:,0].shape)
    L = np.zeros(D[:,:,0].shape,dtype = int)
    #print L.shape
    C = 0
    # Create empty lists to store the values
    dist_values = []
    px_values = []
    dxy_values = []
    for i in range(D.shape[0]):
            # print("ind = ", i)
            for j in range(D.shape[1]):
                    C = C + 1
                    if L[i,j] == 1:
                        continue
                    queue = deque([(i,j)])
                    seen = []
                    while queue:
                        coord = queue.popleft()
                        (x, y) = coord
                        if L[x, y] == 1:
                            continue
                        seen.append(coord)
                        L[x, y] = 1
                        ep = 1
                        ix = -1 * ep
                        while(ix<=ep):
                                jx = -1 * ep
                                while(jx<=ep):
                                        if(x+ix >=0 and y+jx >=0 and x+ix <= D.shape[0]-1 and y+jx <= D.shape[1]-1 and L[x + ix, y + jx] == 0):
                                            px = D[x+ix,y+jx]
                                            #dist = abs(D[x,y] - px)
                                            dist = np.linalg.norm(D[x,y] - px)
                                            d_values[x + ix, y + jx] = dist
                                            # Append the values to the lists
                                            dist_values.append(dist)
                                            px_values.append(px)
                                            dxy_values.append(D[x, y])# Store the d value
                                            #print(D[x,y], px, dist)
                                            if(dist <= rad ):
                                                queue.append((x+ix,y+jx))
                                        jx = jx + 1
                                ix = ix + 1
                    if(len(seen)<min_pts):

                        for k in seen:
                        	Black[k[0],k[1],0] = 0
                        	Black[k[0],k[1],1] = 0
                        	Black[k[0],k[1],2] = 0
                    else:
                        [i_b, i_g, i_r] = random_color()
                        for k in seen:
                                Black[k[0],k[1], 0] = i_b
                                Black[k[0],k[1], 1] = i_g
                                Black[k[0],k[1], 2] = i_r
            # Create a DataFrame to store the values
    # data = pd.DataFrame({'dist': dist_values, 'px': px_values, 'D(x,y)': dxy_values})

    # # Save the DataFrame to an Excel file
    # data.to_excel('D:/HeLa All/j_3frames_results/dist_values.xlsx', index=False)
    return(Black)

"""x,y = regionQuery(I,2,3,3)
print(len(x),len(y))
print(x,y)"""
#np.divide(threeD_Img , 255.0)
# img = DBSCAN(threeD_Img[:, :, :],100,50)
# #cv2.imshow("imput",I)
# cv2.imwrite("DBSCAN_data3_output_1.png",img)
#cv2.waitKey(0)
#cv2.destroyAllWindows()
#tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, kernel)

for im in np.arange(1.12,1.2,0.01):
    print("ind:" + str(im))
    start_time = time.time()
    img = DBSCAN(threeD_Img[:, :, :],im,200)
    end_time = time.time()  # Record the end time
    elapsed_time = end_time - start_time  # Calculate the elapsed time
    print("Time taken for im =", im, " : ", elapsed_time, " seconds")
    cv2.imwrite("/content/drive/MyDrive/dense data/video_res/43/r1eps" + format(im, ".5f") + ".png", img)

cv2.waitKey(0)
cv2.destroyAllWindows()